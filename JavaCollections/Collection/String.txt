What is string in java?
A string in java is an object that represents a sequence of characters.
Strings are immutable , meaning their value cannot be changed once created.

âœ… Ways to Create a String
â¤ Method 1: Using String Literal
String x1 = "mike";
Stored in String pool (special area in heap memory).
Reuses memory if the same literal already exists.

â¤ Method 2: Using new Keyword
String x2= new String("mike");
Always creates a new object in heap memory , outside the String pool.

# String Pool (String constant pool)
Aspecial memory region inside  the heap that stores string literals.
Benefit: Saves memory by reusing existing string literals instead of creating new ones.

Reuse Example:
String s1 = "mike";
String s2 = "mike";
System.out.println(s1==s2);// true (same refrence in pool)

When using new:
String s3 = new String("mike");
System.out.println(s1==s3);// false   (different memory locations)

Important :
Operations like == compare references , not values.
use   .equals() to compare values of strings.

Code Example: Comparing References vs Values
String x1 = "mike";
String x2 = "mike";
String x3 = new String("mike");

System.out.println(x1 == x2);        // true (same pool reference)
System.out.println(x2 == x3);        // false (heap vs pool)
System.out.println(x2.equals(x3));   // true (same content)


String str1 = new String("Ankur");
String str2 = new String("Ankur");

System.out.println(str1 == str2);    // false
System.out.println(str1.equals(str2)); // true

# intern() Method 
Syntax:
String interned = new String("mike").intern();

What it does:
â¤ Checks if the value exists in the String Pool.
â¤ If yes, returns reference from the pool.
â¤ If no, adds the value to the pool and returns that reference.

â¤ Code Example:
String x1 = "mike";
String x3 = new String("mike").intern();

System.out.println(x1 == x3);       // true
System.out.println(x1.equals(x3));  // true

ğŸ“ Check if a String is Empty or Null
String str4 = null;
String str5 = "";

System.out.println(str5.length()); // 0
System.out.println(str4.length()); // âŒ NullPointerException

âš–ï¸ Difference: Null vs Empty String
| Property         | `null`                | `""` (Empty String)     |
| ---------------- | --------------------- | ----------------------- |
| Memory allocated | âŒ No                  | âœ… Yes                   |
| Object created   | âŒ No                  | âœ… Yes                   |
| `.length()`      | âŒ Throws Exception    | âœ… Returns 0             |
| Usability        | Can't call any method | Can call String methods |


ğŸ” How to Check if a String is Empty
âœ… Method 1: isEmpty()
Checks if string length is 0.
If we have a spaces in string it will return false.
Returns: true if empty.

Code Example:
String x1 = "";
System.out.println(x1.isEmpty()); // true

âœ… Method 2: length()
You can manually check if the length is 0.
System.out.println(x1.length() == 0); // true

âœ… Method 3: isBlank()
Returns true if string is:
Empty ("") or
Contains only whitespaces (spaces, tabs, etc.)
Code Example:
String x2 = "   ";
System.out.println(x2.isBlank()); // true
ğŸ”¸ isBlank() is available from Java 11 onwards.

ğŸ§ª String Comparisons
Strings are case-sensitive by default.

âœ… Using equals() method
String str1 = "mike";
String str2 = "mike";
String str3 = "Mike";

System.out.println(str1.equals(str2)); // true
System.out.println(str1.equals(str3)); // false

âœ… Using equalsIgnoreCase() method
Ignores case differences.
System.out.println(str1.equalsIgnoreCase(str3)); // true

ğŸ“Š compareTo() Method
Compares strings lexicographically.
String str6 = "java";
String str7 = "python";

System.out.println(str6.compareTo(str7)); // -6

â¤ Output Meaning:
0 â†’ Both strings are equal.
< 0 â†’ First string is lexicographically smaller.
> 0 â†’ First string is lexicographically greater.

ğŸ”„ String Case Conversion
âœ… toUpperCase()
Converts all characters to uppercase.
"java".toUpperCase(); // "JAVA"

âœ… toLowerCase()
Converts all characters to lowercase.
"JAVa".toLowerCase(); // "java"


âœ‚ï¸ trim() Method
Removes:
Leading (front) and trailing (end) whitespaces.
Does NOT remove spaces or special characters in between the string.
String s = "   hello!@#   ";
System.out.println(s.trim()); // "hello!@#"

âŒ trim() does not remove special characters.
ğŸ”¸ lTrim() and rTrim() are not built-in in Java. You must use regex or custom code to achieve that.

ğŸ”¤ charAt(index)
Returns character at the given index.
String x1 = "aabaacv";
System.out.println(x1.charAt(2)); // 'b'

âœ… Example: Count frequency of a character
String x1 = "aabaacv";
int count = 0;

for (int i = 0; i < x1.length(); i++) {
    if (x1.charAt(i) == 'a') count++;
}
System.out.println(count); // 


# startsWith() & endsWith() methods
-> Both mehtods returns boolean values.
-> Used to check lprefixes or suffixes of string.

Syntax:
str.startsWith("prefix"); // true if string starts with "prefix"
str.endsWith("suffix"); // true if string ends with suffix.

Example:
String s = "Hello world!";
System.out.println(s.strtsWith("he")); // true 
System.out.println(s.endsWith("!"));// true
System.out.println(s.endsWith("World")); // false

#Convert Primitive data types to string
-> Method 1: Add Empty String 
int x= 10'
String y = "" + x:
System.out.println(y);  //"10"
System.out.println(y instanceof String); // ture

Method 2:
float z = 10.3f;
String s1 = String.valueOf(z);
System.out.println(s1); // "10.3"

boolean b = true;
String s2 = String.valueOf(b); // "true"

char ch = 'z';
String s3 = String.valueOf(ch); // "z"

System.out.println(s2); // true
System.out.println(s3); // z
System.out.println(s2 instanceof String); // true
System.out.println(s3 instanceof String); // true

ğŸ”¸ String.valueOf() works for all primitives: int, float, char, boolean, double, long, etc.

# Search in a stirng 
conntains() Method 
-> Checks whether a string contains a specific sequence of characters.
->REturns: true or false 
-> Case -sensitive


String str = "My name is Pankaj";
System.out.println(str.contains("name"));   // true
System.out.println(str.contains("Name"));   // false

 indexOf() Method
â¤ Returns the index of first occurrence of a substring/character.
â¤ If not found, returns -1
â¤ Case-sensitive

â¤ Syntax:
int index = str.indexOf("substring");

Code Example:
String str = "My name is Pankaj;

System.out.println(str.indexOf("name"));   // 3
System.out.println(str.indexOf("Name"));   // -1
System.out.println(str.indexOf(" Ankur")); // 11  

If two parameter is given then it will start the search after the index of the second parameter.
System.out.println(str.indexOf("e",8));  

ğŸ”¹ join() Method
â¤ Used to join elements of an array or any Iterable into a single string.
â¤ Requires a delimiter to separate the elements.

Syntax:
String result = String.join(delimiter, elements...);

âœ… Example:
String[] words = {"Hello", "World", "Java", "Programming"};
String result = String.join(" ", words);
System.out.println(result); // Output: Hello World Java Programming
ğŸ”¸ join() is available from Java 8 onwards.

ğŸ” replace() Method
â¤ Used to replace characters or substrings within a string.
â¤ Returns a new string with replacements applied (original string remains unchanged).

âœ… Method 1: Replace Substring
String s = "Hello World with new Word";
String str = s.replace("Word", "Duniya");
System.out.println(str); // Output: Hello World with new Duniya

âœ… Method 2: Replace Character
String str2 = s.replace('o', '*');
System.out.println(str2); // Output: Hell* W*rld with new W*rd

ğŸ”— Ways of String Concatenation
âœ… Way 1: Using + Operator
String s1 = "Hello";
String s2 = "World";
String result = s1 + " " + s2;
System.out.println(result); // Hello World

âœ… Way 2: Using concat() Method
String result = s1.concat(s2); // HelloWorld

â• Add whitespace between
String result = s1.concat(" ").concat(s2); // Hello World
What is Mutable and Immutable class

ğŸ§  Mutable vs Immutable Classes
| Property        | Immutable Class                             | Mutable Class                             |
| --------------- | ------------------------------------------- | ----------------------------------------- |
| Definition      | Object **cannot be changed** after creation | Object **can be modified** after creation |
| Example         | `String`                                    | `StringBuilder`, `StringBuffer`           |
| Thread-safe?    | Yes (`String`)                              | Only `StringBuffer` is thread-safe        |
| Performance     | Slower (new object on change)               | Faster for frequent modifications         |
| Common Use Case | Constant values, keys in Map                | Dynamic strings in loops or editors       |

ğŸ” How to Design Immutable Classes in Java
An immutable class is one whose state cannot be changed after it is created.

ğŸ§± Design Principles:
âœ… Private and Final Fields
Declare all class fields as private final.
This ensures that fields are set only once and not modified later.
private final String name;

âŒ No Setters
Do not provide any setter methods.
Prevents modification of field values after object creation.

âœ… Initialize via Constructor
All fields must be initialized in the constructor.
Ensures object is in a valid state when created.

ğŸ›¡ï¸ Final Class (Optional but Recommended)
Mark the class as final to prevent inheritance (which might introduce mutability).
public final class Student { ... }

ğŸ›¡ï¸ Defensive Copying (if using mutable fields like arrays, lists)
If the class contains mutable objects (like List, Date, arrays), return a copy instead of the original in getters.

âœ… Example of an Immutable Class:
public final class Student {
    private final String name;
    private final int rollNo;

    public Student(String name, int rollNo) {
        this.name = name;
        this.rollNo = rollNo;
    }

    public String getName() {
        return name;
    }

    public int getRollNo() {
        return rollNo;
    }
}

ğŸŒŸ Benefits of Immutable Classes
âœ… Thread-Safe: No synchronization needed; safe to use in multithreaded environments.
âœ… Reliable & Predictable: Once created, the object remains in the same state.
âœ… Caching & Reuse: Can be safely cached or reused without side effects.
âœ… HashCode Stability: Good for keys in hash-based collections (HashMap, HashSet).

âœ‚ï¸ substring() Method in Java
The substring() method is used to extract a part of the string.

âœ… Syntax Variants:
substring(int start)
Returns substring from start (inclusive) to the end of the string.
String s = "JavaProgramming";
System.out.println(s.substring(4)); // Output: Programming

substring(int start, int end)
Returns substring from start (inclusive) to end (exclusive).
System.out.println(s.substring(0, 4)); // Output: Java

ğŸ§  Remember:
Index starts from 0.
end index is excluded.
Throws StringIndexOutOfBoundsException if indices are invalid.

ğŸ”¹ Method 1: Using \n Escape Character
You can insert line breaks using the newline character \n.
String x = "Hi my name is\nAnkur\nVerma";
System.out.println(x);

âš ï¸ Limitation:
â¤ Becomes tedious and less readable when writing large multi-line strings.
â¤ Manual escaping needed for quotes, line breaks, and indentation.

ğŸ”¹ Method 2: Using Text Blocks (""")
âœ… Introduced in Java 13 (preview), Java 15+ (standard).

Multiline string literal that maintains formatting and is easy to write.
String x2 = """
            Hi 
            My 
            Name 
            is 
            Ankur Verma
            """;
System.out.println(x2);
âœ… Benefits of Text Blocks:
â¤ Easy to write and maintain multiline text (like JSON, SQL, XML, HTML).
â¤ Preserves formatting and indentation.
â¤ No need to use \n for new lines.
â¤ Avoids escaping double quotes in many cases.

################################
String Buffer 
################################
A string buffer is a classs in java that is used to create and manipulate mutable strings. Unlike the regular String class, which is immutable (meaning once a String object is created, it cannot be changed), StringBuffer allows modifications without creating new objects each time.

Key Features of StringBuffer:

->Mutable
You can change the contents (insert, append, delete, replace, etc.) without creating a new object.

->Thread-Safe
All methods in StringBuffer are synchronized, which makes it safe to use in multi-threaded environments.
If you donâ€™t need synchronization, StringBuilder (a faster alternative) is often preferred.

->Capacity Handling
A StringBuffer has a certain capacity (default is 16 characters, plus the length of the string you provide).
When the buffer exceeds this capacity, it automatically increases (usually doubles + 2).


Common Constructors:
StringBuffer sb = new StringBuffer();          // empty buffer, capacity = 16
StringBuffer sb2 = new StringBuffer(30);       // buffer with capacity 30
StringBuffer sb3 = new StringBuffer("Hello");  // initializ

Commonly Used Methods:

append(String s) â†’ adds text at the end.

insert(int index, String s) â†’ inserts at a given position.

replace(int start, int end, String s) â†’ replaces characters between indexes.

delete(int start, int end) â†’ removes characters.

reverse() â†’ reverses the sequence.

capacity() â†’ returns the current capacity.

length() â†’ returns the length of the string.

charAt(int index) â†’ returns a character at a position.

Example:-
public class StringBufferExample {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer("Hello");

        sb.append(" World");          // "Hello World"
        sb.insert(5, ",");            // "Hello, World"
        sb.replace(6, 12, "Java");    // "Hello, Java"
        sb.delete(5, 6);              // "Hello Java"
        sb.reverse();                 // "avaJ olleH"

        System.out.println(sb);
    }
}

####################
STRING Buffer
####################
What is StringBuilder?

->StringBuilder is a mutable sequence of characters in Java.
->Like StringBuffer, it lets you modify strings (append, insert, delete, replace) without creating new objects.
->Key difference: Unlike StringBuffer, StringBuilder is not synchronized, which makes it faster but not thread-safe.

When to Use StringBuilder

Use it when you need to build or modify strings frequently.

Best for single-threaded environments where synchronization isnâ€™t required.

Faster than StringBuffer because it avoids the overhead of synchronization.

Common Methods

Almost the same as StringBuffer:

append(String s) â†’ adds text at the end.
insert(int index, String s) â†’ inserts at a position.
replace(int start, int end, String s) â†’ replaces characters.
delete(int start, int end) â†’ deletes characters.
reverse() â†’ reverses the sequence.
capacity() â†’ returns current buffer size.
length() â†’ length of the string.
charAt(int index) â†’ character at position.

String vs StringBuffer vs StringBuilder
Feature	String (Immutable)	                StringBuffer (Mutable, Synchronized)	StringBuilder (Mutable, Not Synchronized)
Mutability	âŒ No	                       âœ… Yes	                                âœ… Yes
Thread-Safe	âœ… Yes	                       âœ… Yes	                                 âŒ No
Performance	Slow (new object each change)  	Slower (due to synchronization)         Fastest (no sync overhead)

