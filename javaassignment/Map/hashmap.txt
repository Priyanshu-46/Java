ðŸ“’ HashMap in Java 

1. Introduction
âž¤ A HashMap is a part of the Java Collections Framework.
âž¤ It implements the Map interface and stores data in key-value pairs.
âž¤ Keys â†’ Must be unique.
âž¤ Values â†’ Can be duplicated.
âž¤ Null Support â†’ One null key allowed, multiple null values allowed.

2. Hierarchy
Map (Interface)
    |
    v
HashMap (Class)

3. Features of HashMap
âž¤ Unordered: Does not maintain insertion order.
âž¤ Unique Keys: Duplicate keys overwrite the previous value.
âž¤ Null Values: One null key, multiple null values allowed.

âž¤ Time Complexity:
1. Average case â†’ O(1) for put(), get(), remove().
2. Worst case â†’ O(n) (when hash collisions occur heavily).
âž¤ Non-synchronized: Not thread-safe (use Collections.synchronizedMap() or ConcurrentHashMap for thread safety).


5. Example Code
package p1;

import java.util.HashMap;
import java.util.Map;

public class HashMapIntro {
    public static void main(String[] args) {
        Map<String, Integer> mp = new HashMap<>();

        // Adding entries
        mp.put("234567", 3454);
        mp.put("345654", 4544); // Numbers with leading 0 are octal â†’ avoid for strings
        System.out.println(mp); // {234567=3454, 345654=4544}

        // Removing entry
        int val = mp.remove("234567");
        System.out.println(val); // 3454

        // Printing after removal
        System.out.println(mp); // {345654=4544}
    }
}

6. Common Methods
| Method                        | Description                      |
| ----------------------------- | -------------------------------- |
| `put(K key, V value)`         | Adds or updates a key-value pair |
| `get(Object key)`             | Returns value for the given key  |
| `remove(Object key)`          | Removes entry by key             |
| `containsKey(Object key)`     | Checks if key exists             |
| `containsValue(Object value)` | Checks if value exists           |
| `keySet()`                    | Returns set of keys              |
| `values()`                    | Returns collection of values     |
| `entrySet()`                  | Returns set of key-value entries |

7. Iterating through HashMap 
->Using for -each on entrySet()
for(Map.Entry<String,Integer> entry: mp.entrySet()){
    Systen.out.println(entry.getKey()+ "---"+ entry.getValue());

}

->\Using KeySet()
for(String key : mp.keySet()){
    System.out.println(key + "---" + mp.get(key));
}

->Using Iterator
Iterator<Map.Entry<String,Integer>> itr mp.entrySet.iterator();
while (itr.hasNext()){
    Map.entry<String,Integer> entry = itr.next();
    System.out.println(entry.getKey()+ "---" + entry.getvalue());

}

8. Real World use cases in projects 
->Database Caching â†’ Strore query results temporarily with query as key.
->User Sessionn Management â†’  Map sesssion IDs to user objects.
->Counting Occurrences â†’ Word frequency counters in text processing.
->Configuration Settings â†’ Map setting names to their values.

9.Points to Remember 
->Order Not maaintained â†’ Use  LinkedHashMap if you want insertion order.
->Thread Safety â†’ Use ConcurrentHashMap in multi-threaded environments.
->Fail-Fast â†’ Iterators throw ConcurrentModificationException if map is modified duringn iterration( except via iterator's remove()).
->Performance Tuning â†’ You can set intitial capacity and load factor in constructor for better performance.

# Internal working of hashmap in Java
1. Internal Data Structure
âž¤ HashMap internally uses a Hash Table to store data.
âž¤ A hash table is basically an array of buckets.
âž¤ Bucket â†’ Each position in the array can store multiple entries if collisions occur (via linked list or tree).
âž¤ In Java 8+, if a single bucket gets too many elements (default threshold: 8), it is converted from LinkedList to a balanced Red-Black Tree to improve performance from O(n) to O(log n).

2. Initial Capacity
Default initial capacity = 16 buckets (array length).

You can set capacity in the constructor:
Map<String, String> mp = new HashMap<>(32);

This means the hash table will start with 32 buckets.

3. Load Factor
Load factor = 0.75 (default).
Formula: Threshold = Capacity Ã— Load Factor

Example:
Initial capacity = 16
Threshold = 16 Ã— 0.75 = 12

When the 13th entry is inserted, capacity doubles to 32.
New threshold = 32 Ã— 0.75 = 24.

Why Load Factor Exists?
âž¤ To balance time complexity and memory usage.
Higher load factor â†’ fewer resizes (less memory usage, but more collisions).
âž¤ Lower load factor â†’ more resizes (faster lookups, but higher memory usage).

4. hashCode() in HashMap
âž¤ Every Java object has a hashCode() method (from Object class).
âž¤ hashCode() returns an integer representing the objectâ€™s memory-like identity (but not actual memory address).

âž¤ HashMap uses it to determine bucket index:
index = (hashCode(key) & (capacity - 1))
& (capacity - 1) works because capacity is always a power of two â†’ faster than % capacity.

5. Collision in HashMap
âž¤ Collision = Two different keys generate the same bucket index.

How itâ€™s handled:
âž¤ Before Java 8 â†’ Collision handled by LinkedList chaining in the bucket.
âž¤ Java 8 and later:
1. If bucket size < 8 â†’ stored as LinkedList.
2. If bucket size â‰¥ 8 â†’ converted to Red-Black Tree for faster lookups.
3. If bucket size reduces < 6 â†’ Tree is converted back to LinkedList.

Example:
Map<Integer, String> map = new HashMap<>();
map.put(1, "A");
map.put(17, "B"); // 1 and 17 might fall into the same bucket (collision)

1. Internal Data Structure
âž¤ HashMap internally uses a Hash Table to store data.
âž¤ A hash table is basically an array of buckets.
âž¤ Bucket â†’ Each position in the array can store multiple entries if collisions occur (via linked list or tree).
âž¤ In Java 8+, if a single bucket gets too many elements (default threshold: 8), it is converted from LinkedList to a balanced Red-Black Tree to improve performance from O(n) to O(log n).

2. Initial Capacity
Default initial capacity = 16 buckets (array length).

You can set capacity in the constructor:
Map<String, String> mp = new HashMap<>(32);

This means the hash table will start with 32 buckets.

3. Load Factor
Load factor = 0.75 (default).
Formula: Threshold = Capacity Ã— Load Factor

Example:
Initial capacity = 16
Threshold = 16 Ã— 0.75 = 12

When the 13th entry is inserted, capacity doubles to 32.
New threshold = 32 Ã— 0.75 = 24.

Why Load Factor Exists?
âž¤ To balance time complexity and memory usage.
Higher load factor â†’ fewer resizes (less memory usage, but more collisions).
âž¤ Lower load factor â†’ more resizes (faster lookups, but higher memory usage).

4. hashCode() in HashMap
âž¤ Every Java object has a hashCode() method (from Object class).
âž¤ hashCode() returns an integer representing the objectâ€™s memory-like identity (but not actual memory address).

âž¤ HashMap uses it to determine bucket index:
index = (hashCode(key) & (capacity - 1))
& (capacity - 1) works because capacity is always a power of two â†’ faster than % capacity.

5. Collision in HashMap
âž¤ Collision = Two different keys generate the same bucket index.

How itâ€™s handled:
âž¤ Before Java 8 â†’ Collision handled by LinkedList chaining in the bucket.
âž¤ Java 8 and later:
1. If bucket size < 8 â†’ stored as LinkedList.
2. If bucket size â‰¥ 8 â†’ converted to Red-Black Tree for faster lookups.
3. If bucket size reduces < 6 â†’ Tree is converted back to LinkedList.

Example:
Map<Integer, String> map = new HashMap<>();
map.put(1, "A");
map.put(17, "B"); // 1 and 17 might fall into the same bucket (collision)
