What is Collection?
A collection is simp;y an object that represents a gorup of objects, Known as it elements.

What is Collectiono Framework ?
It provides a set of interface and classes that help in managing groups of objects.

Before the introduction of collection framework in JDK 1.2 , Java used to rrely on a variety of classes like Vector , Stack ,Hashtable and arrays to storand manipulate groups of objects.

Drawbacks or limitations
1. Inconstiency :Each class had  a differenet way of managing collections ,leading to confusionand a steep learning curve.
2. Lack of inter-operabilty : These classes were not designed to wrok together seamlesssly.
3. No common Interface: Ther was no common interface for all these classes which meant you couldn't write generic   algorithms that could operate on different typres of collections.


To solve those problems , the collectioon framework was introduced in JDK 1.2.

ğŸ”„Features of Collection Framework:
âœ… Unified architecture: A consistent set of interfaces for all collections.
âœ… Inter-operability: Collections can be easily interchanged and manipulated.
âœ… Reusability: Generic algorithms can be written that work with any collections.
âœ…Efficiency: The framework provides efficient algorithms for basic operations like searching, sorting, and manipulation.

ğŸ”· Key Interfaces in Collection Framework:
1. Collection: The root interface for all other collection types.
2. List: An ordered collection that can contain duplicate elements.(e.g., ArrayList, LinkedList);
3. Set: A collection that cannot contain duplicate elements (e.g., HashSet, TreeSet);
4. Queue: A collection designed for holding elements prior to processing (e.g., PriorityQueue, LinkedList when used as a queue);
5. Deque: A double-ended queue that allows insertion and removal from both ends (e.g., ArrayDeque);
4. Map: An interface that represents a collection of key-value pairs. (e.g. HashMap, TreeMap);

ğŸ”· Hierarchy of Collection Framework:
Iterable
â””â”€â”€ Collection
    â”œâ”€â”€ List
    â”‚   â”œâ”€â”€ ArrayList
    â”‚   â”œâ”€â”€ LinkedList
    â”‚   â”œâ”€â”€ Vector
    â”‚   â”œâ”€â”€ Stack
    â”‚   â””â”€â”€ CopyOnWriteArrayList
    â”‚
    â”œâ”€â”€ Set
    â”‚   â”œâ”€â”€ HashSet
    â”‚   â”œâ”€â”€ LinkedHashSet
    â”‚   â”œâ”€â”€ TreeSet
    â”‚   â”œâ”€â”€ EnumSet
    â”‚   â”œâ”€â”€ ConcurrentSkipListSet
    â”‚   â”œâ”€â”€ SortedSet
    â”‚   â””â”€â”€ CopyOnWriteArraySet
    â”‚
    â””â”€â”€ Queue
        â”œâ”€â”€ LinkedList
        â”œâ”€â”€ PriorityQueue
        â”œâ”€â”€ Deque
        â”‚   â”œâ”€â”€ ArrayDeque
        â”‚   |â”€â”€ LinkedList (also Deque)
        |   |â”€â”€ ConcurrentLinkedDeque
        â”œâ”€â”€ BlockingQueue
        â”‚   â”œâ”€â”€ ArrayBlockingQueue
        â”‚   â”œâ”€â”€ LinkedBlockingQueue
        â”‚   â”œâ”€â”€ PriorityBlockingQueue
        â”‚   â”œâ”€â”€ SynchronousQueue
        â”‚   â””â”€â”€ DelayQueue
        â””â”€â”€ ConcurrentLinkedQueue

ğŸ”· List Interface
A List is an ordered collection that can contain duplicate elements. It allows positional access and insertion of elements.

âœ… Key Features of the List Interface:
â¤ Ordered
â¤ Index-Based access
â¤ Allows duplicates

ğŸŒŸ ArrayList
An ArrayList is a resizable array implementation of the List interface. 
Unlike arrays in Java, which have a fixed size, ArrayList can change its size dynamically as elements are added or removed.
This flexibility makes it a popular choice when the number of elements in a list isn't known in advance.

âœ…Code Implementation of ArrayList:
package collections;

import java.util.ArrayList;

public class ArrayListIntro {

	public static void main(String[] args) {
		ArrayList<Integer> arr = new ArrayList<>();
		// adding elements
		arr.add(1);
		arr.add(5);
		arr.add(80);
		System.out.println(arr.get(2));// accessing the elements
		System.out.println(arr.size());// accessing the size of the arrayList

		System.out.println("");

		// using pointer to iterate on ArrayList
		for (int i = 0; i < arr.size(); i++) {
			System.out.print(arr.get(i) + " ");
		}

		System.out.println("");

		// Iterating using for-each loop
		for (int x : arr) {
			System.out.print(x + " ");
		}
		
		System.out.println("");

		// check for existence of elements
		System.out.println(arr.contains(5));
	
        // removing elements
		//returns the element that is removed and also remove the element
		int element=arr.remove(0);
		System.out.println(element);
		
        //adding elements at specific index
        arr.add(2,50);
        system.out.println(arr); //[1, 5, 50, 80];

        // setting elements at specific index
        arr.set(2, 100);
		System.out.println(arr); // [1, 5, 100, 80]

        // clearing the ArrayList
        arr.clear();
        System.out.println(arr); // []
	}
}

ğŸ”· Internal Working of ArrayList
â¤ Unlike a regular array, which has a fixed size, an ArrayList can grow and shrink as elements are added or removed. 
â¤ This dynamic resizing is achieved by creating a new array when the current array is full and copying the elements to the new array.
â¤ Internally the ArrayList is implemented as an array of Object references. 
â¤ When you add elements to an ArrayList, you're essentially storing these elements in this internal array.
â¤ When you create an ArrayList, it has an initial capacity(default is 10). The capacity refers to the size of the internal array that holds the elements before needing to resize.

ğŸ”· Adding elements
When we add an element to an ArrayList, the following steps occur:

1. Checking Capacity: Before adding the new element, ArrayList checks if there is enough space in the internal array(elementData). IF the array is full, it needs to be resized.

2. Resize if necessary: If the internal array is full, the ArrayList will create a new array with a larger capacity (usually 1.5 times the current capacity) and copy the existing elements from the old array to the new array.

3. Add the Element: The new element is added to the internal array at the appropriate index, and the size is incremented.

ğŸ”· Resizing the Array
1. Initial Capacity: By default, the initial capacityis 10. This means the internal array can hold 10 elements before it needs to grow.

2. Growth Factor: When the internal array is full, a new array is created with a size 1.5 times the old array. This growth factor balances memory efficiency and resizing cost.

3. Copying Elements: When resizing occurs, all elements from the old array are copied to the new array, which is an O(n) operation, where n is the number of elements in the ArrayList.

ğŸ”· Removing Elements
1. Check Bounds: The ArrayList  checks if the index is within the valid range (0 to size - 1).

2. Remove the Element: The element is removed, and all elements to the right of the removed element are shifted to the left to fill the gap.

3. Reduce Size: The size is decremented by 1.

âœ…Code Implementation:

ArrayList<Integer> arr = new ArrayList<>(1000);// creating an ArrayList with initial capacity of 1000
		// adding elements
		System.out.println(arr.size());// gives 0
		System.out.println(arr.get(0));// IndexOutOfBoundsException because no elements are present

//There is no method to print the capacity of an ArrayList directly.

ğŸ”· Creating an ArrayList
âœ…Method 1. Default constructor, creates an empty ArrayList with an initial capacity of 10
		ArrayList<Integer> list=new ArrayList<>();

âœ…Method 2. List is an interface, ArrayList is a class that implements the List interface.
        List<Integer> list2=new ArrayList<>(); 
		
âœ…Method 3. Creating an ArrayList with a specified initial capacity
		ArrayList<Integer> listWithCapacity=new ArrayList<>(20);
		
âœ…Method 4. Creating an ArrayList from another collection
		List<String> anotherList=Arrays.asList("Apple","Banana");//fixed-size list adding and removing elements is not allowed only replacing is allowed
		ArrayList<String> listFromCollection=new ArrayList<>(anotherList);


ğŸ§  Miscellaneous Ways of Creating ArrayList in Java

1. Normal ArrayList
List<String> list = new ArrayList<>();
System.out.println(list.getClass().getName());

âœ…Output: java.util.ArrayList

â¤ This is the regular ArrayList implementation.
â¤ Backed by a resizable array.
â¤ Fully mutable: you can add, remove, and update elements.

2. Using Arrays.asList() with direct values
List<String> list1 = Arrays.asList("Monday", "Tuesday");
System.out.println(list1.getClass().getName());

âœ…Output: java.util.Arrays$ArrayList

â¤ This is NOT java.util.ArrayList
â¤ It is an inner static class of java.util.Arrays called Arrays$ArrayList.
â¤ Characteristics:
    1. Fixed-size list (backed by the given array).
    2. You can modify elements (set()), but cannot add() or remove().
    3. Trying list1.add("Wednesday") will throw UnsupportedOperationException.

list1.set(1, "Friday");   // Works âœ…
System.out.println(list1.get(1)); // Output: Friday

3. Using Arrays.asList() on an existing array
String[] array = {"Apple", "Banana", "Cherry"};
List<String> list2 = Arrays.asList(array);
System.out.println(list2.getClass().getName());

âœ… Output: java.util.Arrays$ArrayList

â¤ Same as above: backed by the array itself.
â¤ Any changes in list2 are reflected in the original array (because they share memory).

list2.set(0, "Mango"); 
System.out.println(array[0]); // Output: Mango (array updated too!)

4. Using List.of() (Java 9+) // Unmodifiable list can't even replace the elements unlike list made from Arrays.asList()
List<Integer> list3 = List.of(1, 2, 3);
System.out.println(list3.getClass().getName());

âœ… Output: java.util.ImmutableCollections$ListN

âœ… Key Points
â¤ new ArrayList<>() â†’ java.util.ArrayList (fully dynamic, resizable).
â¤ Arrays.asList() â†’ java.util.Arrays$ArrayList (fixed-size, backed by array).
â¤ With an existing array, modifications affect both list and array.
â¤ Arrays$ArrayList is an inner class only meant as a lightweight adapter.

âš¡ Quick Trap Question:
ğŸ‘‰ What happens if you call list1.add("Wednesday") on an Arrays.asList() list?
âœ”ï¸ Answer: Throws UnsupportedOperationException because the list is fixed-size.    

ğŸ”· Adding all elements 
âœ…Method 1. In the list at the end
        List<Integer>arr=new ArrayList<>();
		arr.add(1);
		arr.add(2);
		arr.add(3);
		
		List<Integer>list1=List.of(4,5,6,7,8,9);
		//adding all the elements
		arr.addAll(list1);
		
		System.out.println(arr);//âœ…Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]

âœ…Method 2. In the list at specific index
         arr.addAll(2,list1);
         System.out.println(arr);//âœ…Output: [1, 2, 4, 5, 6, 7, 8, 9,3]        


ğŸ”· Removing elements from ArrayList
âœ…Method 1. By index
        arr.remove(2);//removes the element at index 2
        System.out.println(arr);//âœ…Output: [1, 2, 5, 6, 7, 8, 9,3]

âœ…Method 2. By value
        arr.remove(Integer.valueOf(5));//removes the first occurrence of the value 5        

ğŸ”· Converting List to Array
String [] array = arr.toArray(new String[0]);
ğŸ‘‰ This creates a new array of the same type as the list and copies the elements into it.        
ğŸ‘‰ We pass new String[0] to tell the compiler the type of the array we are passing as a argument (Convention).

ğŸ”· Sorting the List
âœ…Method 1: Collections.sort(arr);
ğŸ‘‰ This sorts the list in ascending order using the natural ordering of the elements.

âœ…Method 2: arr.sort(null);
ğŸ‘‰ This sorts the list in ascending order using the natural ordering of 
the elements.
ğŸ‘‰ null is defined here because no custom comparator is used

ğŸ”· Time Complexity of Operations in List
â¤ Accessing by index (get) is O(1).
â¤ Adding an element is O(n) in the worst case when resizing occurs.
â¤ Removing elements can be O(n) because it may involve shifting elements.
â¤ Iteration is O(n).

ğŸ”· Comparator
It is an interface that defines a method for comparing two objects of the same type.
It is used to sort objects in a custom order.

ğŸ”· How to use Comparator
public class ArrayListIntro {

	public static void main(String[] args) {
		List<Integer>arr=new ArrayList<>();
		arr.add(1);
		arr.add(2);
		arr.add(3);
		
		List<Integer>list1=List.of(4,5,6,7,8,9);
		//adding all the elements
		arr.addAll(2,list1);
		
		arr.sort(new CustomComparator());
		System.out.println(arr); // Output: [9, 8, 7, 6, 5, 4, 3, 2, 1]
	}
}
class CustomComparator implements Comparator<Integer>{

	@Override
	public int compare(Integer o1, Integer o2) {
		return o2-o1;
	}
}
ğŸ‘‰ If we do o1-o2, it will sort in ascending order

ğŸ”· Using lambda expression
âœ… Example 1: Sorting Lexicographically
		List<String>str=Arrays.asList("Apple", "Mango","Banana");
		str.sort((a,b)-> a.compareTo(b));
		//if gives negative then first will come
		System.out.println(str); // Output: [Apple, Banana, Mango]

âœ… Example 2: Sorting by Length		
		List<String>str2=Arrays.asList("Apple", "Plum","Banana");
		str2.sort((a,b)-> a.length()-b.length());
		System.out.println(str2);// Output: [Plum, Apple, Banana]
    Example 3:from java 8 

      List<Student> list = new ArrayList<>();
        list.add(new Student("Charlie", 3.5));
        list.add(new Student("Bob", 3.7));
        list.add(new Student("Alice", 3.5));
        list.add(new Student("Akshit", 3.9));

        Comparator<Student> comparator = Comparator.comparing(Student::getGpa).reversed().thencomparing(Student::getName);
        students.sort(comparator);

##########################################################
LinkedList
##########################################################
A linkedlist is a doubly-linkedlist implementation of the list and Deque interface.
It allows for efficient insertion and removal of elements at both ends of the list.

Customm Made LinkedList Implementation 
package collections;

public class LinkedListIntro {
	Node node1=new Node();
	Node node1 = new Node();
	node1.value=10;
	node1.next=null;

	Node node2=new Node();
	node2.value=2;
	node2.next=nill;
	node1.next=node2;

	Node temp=node1;
	while (remp!=null){
		System.out.printnln(temp.value);
		temp=temp.next;

	}
}
  
  class Node{
	System.out.println(temp.value);
	temp=temp.next;
  }

A linkedlList is aal linear data structure wherre each elememt is a seperate oblect called a node . Each node contains two parts:
1. Data: The value stord in the node .
2. Pointer /reference: teo poinnterrs , onne points to the next node (next) and the other poinnting to previous node (previous).

Performance cconsniderations 
->LinkedList has different perdormance characteristics compared to ArryList:
Insertion andd Deletion : LinkedList is betterr for frequent insertions and deletions in the midddle of the list because it does not require shifting elements , as in ArayList.
Random Acess : LinkedList has sloweer random access(get(int index)) comparred to ArrayList because it has to traverrse the list from te beginning to reach the desired index.
Memory Overhead: LinkedList requires more memory than ArrayList because each node in a LinkedList requires extra memory to store the next and the previous node.


 

