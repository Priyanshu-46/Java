What is string in java?
A string in java is an object that represents a sequence of characters.
Strings are immutable , meaning their value cannot be changed once created.

✅ Ways to Create a String
➤ Method 1: Using String Literal
String x1 = "mike";
Stored in String pool (special area in heap memory).
Reuses memory if the same literal already exists.

➤ Method 2: Using new Keyword
String x2= new String("mike");
Always creates a new object in heap memory , outside the String pool.

# String Pool (String constant pool)
Aspecial memory region inside  the heap that stores string literals.
Benefit: Saves memory by reusing existing string literals instead of creating new ones.

Reuse Example:
String s1 = "mike";
String s2 = "mike";
System.out.println(s1==s2);// true (same refrence in pool)

When using new:
String s3 = new String("mike");
System.out.println(s1==s3);// false   (different memory locations)

Important :
Operations like == compare references , not values.
use   .equals() to compare values of strings.

Code Example: Comparing References vs Values
String x1 = "mike";
String x2 = "mike";
String x3 = new String("mike");

System.out.println(x1 == x2);        // true (same pool reference)
System.out.println(x2 == x3);        // false (heap vs pool)
System.out.println(x2.equals(x3));   // true (same content)


String str1 = new String("Ankur");
String str2 = new String("Ankur");

System.out.println(str1 == str2);    // false
System.out.println(str1.equals(str2)); // true

# intern() Method 
Syntax:
String interned = new String("mike").intern();

What it does:
➤ Checks if the value exists in the String Pool.
➤ If yes, returns reference from the pool.
➤ If no, adds the value to the pool and returns that reference.

➤ Code Example:
String x1 = "mike";
String x3 = new String("mike").intern();

System.out.println(x1 == x3);       // true
System.out.println(x1.equals(x3));  // true

📏 Check if a String is Empty or Null
String str4 = null;
String str5 = "";

System.out.println(str5.length()); // 0
System.out.println(str4.length()); // ❌ NullPointerException

⚖️ Difference: Null vs Empty String
| Property         | `null`                | `""` (Empty String)     |
| ---------------- | --------------------- | ----------------------- |
| Memory allocated | ❌ No                  | ✅ Yes                   |
| Object created   | ❌ No                  | ✅ Yes                   |
| `.length()`      | ❌ Throws Exception    | ✅ Returns 0             |
| Usability        | Can't call any method | Can call String methods |


🔍 How to Check if a String is Empty
✅ Method 1: isEmpty()
Checks if string length is 0.
If we have a spaces in string it will return false.
Returns: true if empty.

Code Example:
String x1 = "";
System.out.println(x1.isEmpty()); // true

✅ Method 2: length()
You can manually check if the length is 0.
System.out.println(x1.length() == 0); // true

✅ Method 3: isBlank()
Returns true if string is:
Empty ("") or
Contains only whitespaces (spaces, tabs, etc.)
Code Example:
String x2 = "   ";
System.out.println(x2.isBlank()); // true
🔸 isBlank() is available from Java 11 onwards.

🧪 String Comparisons
Strings are case-sensitive by default.

✅ Using equals() method
String str1 = "mike";
String str2 = "mike";
String str3 = "Mike";

System.out.println(str1.equals(str2)); // true
System.out.println(str1.equals(str3)); // false

✅ Using equalsIgnoreCase() method
Ignores case differences.
System.out.println(str1.equalsIgnoreCase(str3)); // true

📊 compareTo() Method
Compares strings lexicographically.
String str6 = "java";
String str7 = "python";

System.out.println(str6.compareTo(str7)); // -6

➤ Output Meaning:
0 → Both strings are equal.
< 0 → First string is lexicographically smaller.
> 0 → First string is lexicographically greater.

🔄 String Case Conversion
✅ toUpperCase()
Converts all characters to uppercase.
"java".toUpperCase(); // "JAVA"

✅ toLowerCase()
Converts all characters to lowercase.
"JAVa".toLowerCase(); // "java"


✂️ trim() Method
Removes:
Leading (front) and trailing (end) whitespaces.
Does NOT remove spaces or special characters in between the string.
String s = "   hello!@#   ";
System.out.println(s.trim()); // "hello!@#"

❌ trim() does not remove special characters.
🔸 lTrim() and rTrim() are not built-in in Java. You must use regex or custom code to achieve that.

🔤 charAt(index)
Returns character at the given index.
String x1 = "aabaacv";
System.out.println(x1.charAt(2)); // 'b'

✅ Example: Count frequency of a character
String x1 = "aabaacv";
int count = 0;

for (int i = 0; i < x1.length(); i++) {
    if (x1.charAt(i) == 'a') count++;
}
System.out.println(count); // 


# startsWith() & endsWith() methods
-> Both mehtods returns boolean values.
-> Used to check lprefixes or suffixes of string.

Syntax:
str.startsWith("prefix"); // true if string starts with "prefix"
str.endsWith("suffix"); // true if string ends with suffix.

Example:
String s = "Hello world!";
System.out.println(s.strtsWith("he")); // true 
System.out.println(s.endsWith("!"));// true
System.out.println(s.endsWith("World")); // false

#Convert Primitive data types to string
-> Method 1: Add Empty String 
int x= 10'
String y = "" + x:
System.out.println(y);  //"10"
System.out.println(y instanceof String); // ture

Method 2:
float z = 10.3f;
String s1 = String.valueOf(z);
System.out.println(s1); // "10.3"

boolean b = true;
String s2 = String.valueOf(b); // "true"

char ch = 'z';
String s3 = String.valueOf(ch); // "z"

System.out.println(s2); // true
System.out.println(s3); // z
System.out.println(s2 instanceof String); // true
System.out.println(s3 instanceof String); // true

🔸 String.valueOf() works for all primitives: int, float, char, boolean, double, long, etc.

# Search in a stirng 
conntains() Method 
-> Checks whether a string contains a specific sequence of characters.
->REturns: true or false 
-> Case -sensitive


String str = "My name is Pankaj";
System.out.println(str.contains("name"));   // true
System.out.println(str.contains("Name"));   // false

 indexOf() Method
➤ Returns the index of first occurrence of a substring/character.
➤ If not found, returns -1
➤ Case-sensitive

➤ Syntax:
int index = str.indexOf("substring");

Code Example:
String str = "My name is Pankaj;

System.out.println(str.indexOf("name"));   // 3
System.out.println(str.indexOf("Name"));   // -1
System.out.println(str.indexOf(" Ankur")); // 11  

If two parameter is given then it will start the search after the index of the second parameter.
System.out.println(str.indexOf("e",8));  

🔹 join() Method
➤ Used to join elements of an array or any Iterable into a single string.
➤ Requires a delimiter to separate the elements.

Syntax:
String result = String.join(delimiter, elements...);

✅ Example:
String[] words = {"Hello", "World", "Java", "Programming"};
String result = String.join(" ", words);
System.out.println(result); // Output: Hello World Java Programming
🔸 join() is available from Java 8 onwards.

🔁 replace() Method
➤ Used to replace characters or substrings within a string.
➤ Returns a new string with replacements applied (original string remains unchanged).

✅ Method 1: Replace Substring
String s = "Hello World with new Word";
String str = s.replace("Word", "Duniya");
System.out.println(str); // Output: Hello World with new Duniya

✅ Method 2: Replace Character
String str2 = s.replace('o', '*');
System.out.println(str2); // Output: Hell* W*rld with new W*rd

🔗 Ways of String Concatenation
✅ Way 1: Using + Operator
String s1 = "Hello";
String s2 = "World";
String result = s1 + " " + s2;
System.out.println(result); // Hello World

✅ Way 2: Using concat() Method
String result = s1.concat(s2); // HelloWorld

➕ Add whitespace between
String result = s1.concat(" ").concat(s2); // Hello World
What is Mutable and Immutable class

🧠 Mutable vs Immutable Classes
| Property        | Immutable Class                             | Mutable Class                             |
| --------------- | ------------------------------------------- | ----------------------------------------- |
| Definition      | Object **cannot be changed** after creation | Object **can be modified** after creation |
| Example         | `String`                                    | `StringBuilder`, `StringBuffer`           |
| Thread-safe?    | Yes (`String`)                              | Only `StringBuffer` is thread-safe        |
| Performance     | Slower (new object on change)               | Faster for frequent modifications         |
| Common Use Case | Constant values, keys in Map                | Dynamic strings in loops or editors       |

🔐 How to Design Immutable Classes in Java
An immutable class is one whose state cannot be changed after it is created.

🧱 Design Principles:
✅ Private and Final Fields
Declare all class fields as private final.
This ensures that fields are set only once and not modified later.
private final String name;

❌ No Setters
Do not provide any setter methods.
Prevents modification of field values after object creation.

✅ Initialize via Constructor
All fields must be initialized in the constructor.
Ensures object is in a valid state when created.

🛡️ Final Class (Optional but Recommended)
Mark the class as final to prevent inheritance (which might introduce mutability).
public final class Student { ... }

🛡️ Defensive Copying (if using mutable fields like arrays, lists)
If the class contains mutable objects (like List, Date, arrays), return a copy instead of the original in getters.

✅ Example of an Immutable Class:
public final class Student {
    private final String name;
    private final int rollNo;

    public Student(String name, int rollNo) {
        this.name = name;
        this.rollNo = rollNo;
    }

    public String getName() {
        return name;
    }

    public int getRollNo() {
        return rollNo;
    }
}

🌟 Benefits of Immutable Classes
✅ Thread-Safe: No synchronization needed; safe to use in multithreaded environments.
✅ Reliable & Predictable: Once created, the object remains in the same state.
✅ Caching & Reuse: Can be safely cached or reused without side effects.
✅ HashCode Stability: Good for keys in hash-based collections (HashMap, HashSet).

✂️ substring() Method in Java
The substring() method is used to extract a part of the string.

✅ Syntax Variants:
substring(int start)
Returns substring from start (inclusive) to the end of the string.
String s = "JavaProgramming";
System.out.println(s.substring(4)); // Output: Programming

substring(int start, int end)
Returns substring from start (inclusive) to end (exclusive).
System.out.println(s.substring(0, 4)); // Output: Java

🧠 Remember:
Index starts from 0.
end index is excluded.
Throws StringIndexOutOfBoundsException if indices are invalid.

🔹 Method 1: Using \n Escape Character
You can insert line breaks using the newline character \n.
String x = "Hi my name is\nAnkur\nVerma";
System.out.println(x);

⚠️ Limitation:
➤ Becomes tedious and less readable when writing large multi-line strings.
➤ Manual escaping needed for quotes, line breaks, and indentation.

🔹 Method 2: Using Text Blocks (""")
✅ Introduced in Java 13 (preview), Java 15+ (standard).

Multiline string literal that maintains formatting and is easy to write.
String x2 = """
            Hi 
            My 
            Name 
            is 
            Ankur Verma
            """;
System.out.println(x2);
✅ Benefits of Text Blocks:
➤ Easy to write and maintain multiline text (like JSON, SQL, XML, HTML).
➤ Preserves formatting and indentation.
➤ No need to use \n for new lines.
➤ Avoids escaping double quotes in many cases.

################################
String Buffer 
################################
A string buffer is a classs in java that is used to create and manipulate mutable strings. Unlike the regular String class, which is immutable (meaning once a String object is created, it cannot be changed), StringBuffer allows modifications without creating new objects each time.

Key Features of StringBuffer:

->Mutable
You can change the contents (insert, append, delete, replace, etc.) without creating a new object.

->Thread-Safe
All methods in StringBuffer are synchronized, which makes it safe to use in multi-threaded environments.
If you don’t need synchronization, StringBuilder (a faster alternative) is often preferred.

->Capacity Handling
A StringBuffer has a certain capacity (default is 16 characters, plus the length of the string you provide).
When the buffer exceeds this capacity, it automatically increases (usually doubles + 2).


Common Constructors:
StringBuffer sb = new StringBuffer();          // empty buffer, capacity = 16
StringBuffer sb2 = new StringBuffer(30);       // buffer with capacity 30
StringBuffer sb3 = new StringBuffer("Hello");  // initializ

Commonly Used Methods:

append(String s) → adds text at the end.

insert(int index, String s) → inserts at a given position.

replace(int start, int end, String s) → replaces characters between indexes.

delete(int start, int end) → removes characters.

reverse() → reverses the sequence.

capacity() → returns the current capacity.

length() → returns the length of the string.

charAt(int index) → returns a character at a position.

Example:-
public class StringBufferExample {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer("Hello");

        sb.append(" World");          // "Hello World"
        sb.insert(5, ",");            // "Hello, World"
        sb.replace(6, 12, "Java");    // "Hello, Java"
        sb.delete(5, 6);              // "Hello Java"
        sb.reverse();                 // "avaJ olleH"

        System.out.println(sb);
    }
}

####################
STRING Buffer
####################
What is StringBuilder?

->StringBuilder is a mutable sequence of characters in Java.
->Like StringBuffer, it lets you modify strings (append, insert, delete, replace) without creating new objects.
->Key difference: Unlike StringBuffer, StringBuilder is not synchronized, which makes it faster but not thread-safe.

When to Use StringBuilder

Use it when you need to build or modify strings frequently.

Best for single-threaded environments where synchronization isn’t required.

Faster than StringBuffer because it avoids the overhead of synchronization.

Common Methods

Almost the same as StringBuffer:

append(String s) → adds text at the end.
insert(int index, String s) → inserts at a position.
replace(int start, int end, String s) → replaces characters.
delete(int start, int end) → deletes characters.
reverse() → reverses the sequence.
capacity() → returns current buffer size.
length() → length of the string.
charAt(int index) → character at position.

String vs StringBuffer vs StringBuilder
Feature	String (Immutable)	                StringBuffer (Mutable, Synchronized)	StringBuilder (Mutable, Not Synchronized)
Mutability	❌ No	                       ✅ Yes	                                ✅ Yes
Thread-Safe	✅ Yes	                       ✅ Yes	                                 ❌ No
Performance	Slow (new object each change)  	Slower (due to synchronization)         Fastest (no sync overhead)

